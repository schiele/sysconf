#!/bin/bash
set -eu
GITROOT=~/git
if test $# = 2; then
    GITPATH="$1"
    GITOPTS=("$GITPATH" "$2")
else
    case "$1" in
        *:*)
            GITPATH="$1"
            GITOPTS=("$GITPATH")
            ;;
        *)
            case "$1" in
                /*) FULLPATH="$1/";;
                *)  FULLPATH="$PWD/$1/";;
            esac
            pathsubst()
            {
                local OLDFULLPATH="$FULLPATH/xxx"
                while test "$OLDFULLPATH" != "$FULLPATH"; do
                    OLDFULLPATH="$FULLPATH"
                    FULLPATH="$(sed -e "$1" <<< "$FULLPATH")"
                done
            }
            pathsubst 's,/\./,/,'
            pathsubst 's,//,/,'
            pathsubst 's,/[^/]*/\.\./,/,'
            pathsubst 's,/$,,'
            GITPATH="$(sed -ne "s,^$GITROOT/\([^/]*\)/\(.*\)$,\1:\2,p" <<< "$FULLPATH")"
            if test -z "$GITPATH"; then
                echo >&2 "invalid pattern $1"
                false
            fi
            GITOPTS=("$GITPATH" "$1")
            ;;
    esac
fi

HASHES=$(mktemp)
git ls-remote "$GITPATH" | awk '{print $1}' | sort -u > "$HASHES"
test ${PIPESTATUS[0]} = 0
echo -n 'Finding similarities... '
SIMILAR=$(
    find "$GITROOT" -name .git |
    while read DIR; do
        SIMILARITY=$((
            git ls-remote $DIR | awk '{print $1}' | sort -u
            cat "$HASHES"
        ) | sort | uniq -d | wc -l)
        test "$SIMILARITY" = 0 || echo $SIMILARITY $DIR
    done | sort -nr | awk '{print $2}' | head -n 1
)
rm -rf "$HASHES"
if test "$SIMILAR"; then
    GITOPTS=(--reference "$SIMILAR" --dissociate "${GITOPTS[@]}")
    echo "$SIMILAR"
else
    echo none
fi
exec git clone "${GITOPTS[@]}"
